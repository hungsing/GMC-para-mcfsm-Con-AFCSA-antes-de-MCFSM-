\documentclass[paper=a4, fontsize=11pt, spanish]{scrartcl} % A4 paper and 11pt font size
\usepackage[T1]{fontenc} % Use 8-bit encoding that has 256 glyphs
\usepackage{fourier} % Use the Adobe Utopia font for the document - comment this line to return to the LaTeX default
\usepackage[spanish]{babel} % English language/hyphenation
\selectlanguage{spanish}
\usepackage[utf8]{inputenc}
\usepackage{,amsmath,amsfonts,amsthm} % Math packages
\usepackage{amssymb}
\usepackage{mathtools}
%\usepackage{xypic}
\usepackage{tikz}
\usetikzlibrary{babel,automata,positioning,arrows}
\usepackage{graphicx}
\usepackage[rightcaption]{sidecap}
\usepackage{pgfplots}
\pgfplotsset{compat=newest}
\usepackage{xcolor}
\usepackage{paralist}
\usepackage{stackengine}
\usepackage[shortlabels]{enumitem}
% \usepackage{txfonts}
% \usepackage{framed,color}
% \usepackage{todonotes}
\newcommand*{\corner}{\mbox{\LARGE{$\mathrlap{\cdot}\lrcorner$}}}

\usepackage{sectsty} % Allows customizing section commands
\allsectionsfont{\centering \normalfont\scshape} % Make all sections centered, the default font and small caps

\usepackage{xspace}
\usepackage{xcolor}
\usepackage{framed,color}
\usepackage{todonotes}
\definecolor{LavanderPosta}{HTML}{ebd9fc}
\newcommand{\enote}[1]{\todo[fancyline,color=LavanderPosta]{#1 \\{\footnotesize(Eze)}}\xspace{}}
\newcommand{\cnote}[1]{\todo[fancyline,color=LavanderPosta]{#1 \\{\footnotesize(Charlie)}}\xspace{}}



\usepackage{fancyhdr} % Custom headers and footers
\pagestyle{fancyplain} % Makes all pages in the document conform to the custom headers and footers
\fancyhead{} % No page header - if you want one, create it in the same way as the footers below
\fancyfoot[L]{} % Empty left footer
\fancyfoot[C]{} % Empty center footer
\fancyfoot[R]{\thepage} % Page numbering for right footer
\renewcommand{\headrulewidth}{0pt} % Remove header underlines
\renewcommand{\footrulewidth}{0pt} % Remove footer underlines
\setlength{\headheight}{13.6pt} % Customize the height of the header

\numberwithin{equation}{section} % Number equations within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)
\numberwithin{figure}{section} % Number figures within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)
\numberwithin{table}{section} % Number tables within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)

\setlength\parindent{0pt} % Removes all indentation from paragraphs - comment this line for an assignment with lots of text
\newtheorem{example}{Example}
\newtheorem{definition}{Definición}
\newtheorem{prop}{Proposición}
\input{macros}
\newcommand{\defname}[1]{\textbf{\emph{[#1]}}}
\newcommand{\theoname}[1]{\textbf{\emph{[#1]}}}
\newcommand{\propname}[1]{\textbf{\emph{[#1]}}}
\newcommand{\romboeqb}{\underline{\diamond}}
\newcommand{\romboeqn}{\underline{\blacklozenge}}
% \newcommand{\cfsmalphabet}{\ensuremath{\mathcal{A}}}

% \newcommand{\cnote}[1]{\todo[fancyline,color=LavanderPosta]{#1 \\{\footnotesize(Charlie)}}\xspace{}}

\pgfkeys{/pgfplots/Axis Style/.style={
width=7.5cm, height=8cm,
axis x line=center, 
axis y line=middle, 
samples=100,
ymin=-1.5, ymax=5.5,
xmin=-7.0, xmax=7.0,
domain=-2*pi:2*pi,
title style={at={(1,0.5)}}
}}
\begin{document}
\begin{abstract}

\end{abstract}

\section{Introducción}

\section{Propiedades de la Comunicación Asincrónica}
\subsection{Introducción}

\subsection{Definiciones preliminares}
\label{preliminares}
A continuación presentaremos algunas definiciones y resultados preliminares que serán de utilidad en las restantes secciones de esta tesis.

\begin{itemize}
    \item Def. Clausura reflexo-transitiva. Sea $\rightarrow$ una relación sobre un conjunto S. La clausura reflexo-transitiva de $\rightarrow$, denotada  $\rightarrow^*$, se define como la relación reflexiva y transitiva más pequeña sobre S que contiene a $\rightarrow$. 
    \item Def. Relación de equivalencia es una relación binaria reflexiva, simétrica y transitiva. La relación "es igual a" es el ejemplo canónico donde para todo trío de objetos a, b y c, vale: \\
    \begin{inparaenum}
    \item a= a (propiedad reflexiva) \\
    \item Si a = b entonces b = a (propiedad de simetría) \\
    \item Si a = b y b = c entonces a = c (propiedad transitiva)
    \end{inparaenum}
    \item Prop. La clausura reflexo-transitiva de una relación binaria es una relación de equivalencia
\end{itemize}

\subsection{Communicating Finite State Machines}

El concepto de \emph{Communicating Finite State Machines} -- CFSM fue introducido en \cite{CFSM} con el objetivo modelar y estudiar el comportamiento de sistemas distribuidos constituídos por un conjunto de procesos secuenciales que ejecutan concurrentemente y se comunican a partir de intercambiar mensajes a través de canales de comunicación previamente declarados. Fijamos .

\begin{definition}[Communicating Finite State Machines] Sea $\mathcal{M}$ un conjunto finito de mensajes y un conjunto finito de mensajes  y un conjunto finito de participantes $\mathcal{P}$ un conjunto finito de participantes, definimos una communicating finite state machine -- CFSM sobre $\mathcal{M}$ como un sistema de transición finito $(Q, C, q_0, \mathcal{M}, \delta)$ donde
\begin{itemize}
  \item $Q$ es un conjunto finito de estado;
  \item $C = \left\{ pq \in \mathcal{P}^2 \left|\right. p \not= q\right\}$ es un conjunto de canales
  \item $q_0 \in Q$ es el estado inicial;
  \item $\delta \subseteq Q \times (C \times \{!,?\} \times \mathcal{M}) \times Q$ es un conjunto finito de \emph{transiciones}.
  \end{itemize}
  
\end{definition} 

A partir de la introducción de las CFSMs, la siguiente definición introduce el concepto de \emph{Communicating System} \cite[Def.2.2]{Communicating System} como un conjunto de CFSMs que cumplen determinadas propiedades.

\begin{definition}[Communicating System] Dada una CFSM $\textit{M}_p = (Q_p, q_{0_p}, \mathcal{M}, \delta_p) $ para cada participante $p \in \mathcal{P}$, la tupla $S= (M_p)_{p \in \mathcal{P}} $ es un communicating system CS. Una configuración de S es un par $s = (\overrightarrow{q} ; \overrightarrow{w})$ donde $\overrightarrow{q} = (q_p)_{p \in \mathcal{P}}$ con $q_p \in Q_p$ y donde $\overrightarrow{w} = (w_{pq})_{pq \in C}$ con $ w_{pq} \in \mathcal{M}^*$. La componente $\overrightarrow{q}$ es el estado de control y $q_p \in Q_p$ es el estado local de la máquina $ M_p$. La configuración inicial de S es $s_0 = (\overrightarrow{q_0} ; \overrightarrow{\epsilon}) $ con $\overrightarrow{q_0} = (q_{0_p})_{p \in \mathcal{P}} $
% Un \emph{communicating system} es un mapa \textit{S} que asigna una CFSM $S(p)$ a cada $p \in \mathcal{P}$. Escribimos $q \in S(p)$ cuando $q$ es un estado de la máquina $S(p)$ y $t \in S(p)$ cuando $t$ es una transición de $S(p)$.\\

\end{definition}

La semántica de los CSs está dada por un sistema de transición etiquetado \cite{lts} cuyos estados y transiciones determinan las posibles ejecuciones del conjunto de procesos sobre el que está definido el sistema.

\begin{definition}[Estados y configuraciones alcanzables]
  Una configuración $s' = \sysconf{q'}{w'}$ es \emph{alcanzable} desde otra
  configuración $s = \sysconf{q}{w}$ a través de la \emph{ejecución de la
    transición} $t$ (esmcrito $s \overset{t}{\rightarrow} s'$) si existe un
   $\amsg \in \mathcal{M}$ tal que ocurre una de las siguientes alternativas:
	\begin{enumerate}
		\item $t = (q_\p, \p\q!\amsg,  q'_\p) \in \delta_\p$ y 
			\begin{enumerate}
				\item \(q'_{\p'} = q_{\p'}\) for all $\p' \not= \p$; y
				\item $w'_{\p\q} = w_{\p\q} \cdot \amsg$ and $w'_{\p'\q'} = w_{\p'\q'}$ for all $\p'\q' \not= \p\q$; O bien
			\end{enumerate}
		\item $t = (q_\q, \p\q?\amsg,  q'_\q) \in \delta_\q$ y 
			\begin{enumerate}
			\item $q'_{\p'} = q_{\p'}$ para todo $\p' \not= \q$; y
				\item $\amsg \cdot w'_{\p\q} = w_{\p\q}$ y $w'_{\p'\q'} = w_{\p'\q'}$ para todo $\p'\q' \not= \p\q$
			\end{enumerate}
	\end{enumerate}
Escribimos $ s_1 \overset{t1...tm}{\rightarrow} s_{m+1}$ cuando para algún $s_2,...,s_m, s_1\overset{t}{\rightarrow} s_2...s_m\overset{t_m}{\rightarrow} s_{m+1} $ . El conjunto de configuraciones alcanzables de S es $RS(S) = \{s | s_0 \rightarrow^*S \}$
\end{definition}

En adelante presentaremos definiciones y resultados que permiten expresar propiedades de los CSs introducidos en la definición anterior.

\begin{definition}[Communicating System seguro] Sea $S$ un CS; se dice que $S$ es \emph{seguro} si para cada $s \in RS(S)$:
\begin{inparaenum}[1.]
\item $s$ no es una configuración de deadlock, 
\item $s$ no posee mensajes huérfanos, y
\item $s$ no posee recepciones no especificadas.
\end{inparaenum}
Para poder expresar esta condición de seguridad es necesario identificar conjuntos de acciones que pueden ser llevadas a cabo concurrentemente. Para esto definimos las siguientes relaciones sobre el conjunto de transiciones de una CFSM. Dados $q, q' \in Q$, se define $\mathit{act}(q,q') = \left\{\ell \ \left|\right. \ (q,\ell,q') \in \delta \right\}$ y $\Diamond, \blacklozenge \subseteq \delta \times \delta$ como las relaciones de equivalencia más pequeñas que contienen $\underline{\Diamond}$ y $\underline{\blacklozenge}$ donde:
\begin{itemize}
\item $(q_1, \ell, q_2) \underline{\Diamond} (q'_1, \ell, q'_2)$ sii $ l \notin \mathit{act}(q_1, q'_1) \land \mathit{act}(q_1, q'_1) = \mathit{act}(q_2, q'_2) \land \mathit{act}(q_2, q'_2) \neq \emptyset $
\item  $(q_1, \ell, q_2) \underline{\blacklozenge} (q'_1, \ell, q'_2)$ sii $ (q_1, \ell, q_2) \romboeqb (q'_1, \ell, q'_2) $ y para todo $(q,\ell,q') \in [(q_1, \ell, q_2) ]^{\Diamond}, \ \mathit{act}(q_1,q) = \mathit{act}(q_2,q') \land \mathit{act}(q'_1,q) = \mathit{act}(q'_2,q')$  
\end{itemize}
donde $[(q_1, \ell, q_2) ]^{\Diamond}$ es la clase de equivalencia de $(q, \ell, q')$ respecto de la relación $\Diamond$ (resp. $\blacklozenge$). Intuitivamente dos transiciones están $\blacklozenge$-relacionadas si se refieren a la misma acción aún teniendo en cuenta el interleaving.
\end{definition}

\begin{example}[Ejemplo]

\end{example}

\begin{tikzpicture}[->, thick]
 \node[state,initial] (q_0)   {$q_0$}; 
 \node[state] (q_1) [right= of q_0 ] {$q_1$};
 \node[state] (q_5) [right= of q_1 ] {$q_5$};
 \node[state] (q_2) [below= of q_0 ] {$q_2$};
 \node[state] (q_3) [right= of q_2 ] {$q_3$};
 \node[state,accepting] (q_6) [right= of q_3 ] {$q_6$};
 \draw[]        
        (q_0) edge[above] node{sr!a} (q_1)
        (q_0) edge[right] node{sr!b} (q_2)
        (q_1) edge[right] node{sr'!b} (q_3)
        (q_1) edge[above] node{sr!a} (q_5)
        (q_2) edge[above] node{sr'!a} (q_3)
        (q_2) edge[bend right, below] node{sr!c} (q_6)
        (q_3) edge[above] node{sr!a} (q_6)
        (q_5) edge[right] node{sr'!b} (q_6)
        ;
\node[anchor = west, right] at (5,0) {1)  $(q_0, sr!a,q1) \underline{\Diamond} (q_2,sr!a,q3)  $};
\node[anchor = west, right] at (5,-0.75) {2)  $(q_0, sr!a,q1) \underline{\blacklozenge} (q_2,sr!a,q3)   $};
\node[anchor = west, right] at (5,-1.5) {3) $ \neg ((q_0, sr!a,q1) \underline{\Diamond} (q_1,sr'!b,q5)) $};
\node[anchor = west, right]at (5,-2.25){4) $ (q_0, sr'!b,q2) \underline{\Diamond} (q_1, sr'!b,q3)$};
\node[anchor = west, right]at (5,-3){5) $ \neg ((q_0, sr'!b,q2) \underline{\blacklozenge} (q_1,sr'!b,q_3)) $};
\end{tikzpicture} 

Las relaciones en (1-2) se sostienen dado que ambas transiciones están interleaved (traducir) con $sr'!b$. La relacion en (3) no se sostiene debido a que la transición entre el origen de una $(q_0)$ y el del otro $(q_1)$ pasa por $sr!a$. Ambas transiciones en (3) son secuenciales, no concurrentes. La relación en (4) se sostiene, pero en (5) no porque $(q_5,sr'!b,q_6)$ está en la clase de $Diamond$-equivalencia de $(q_0,sr'!b,q_2)$ para la cual la condición no se sostiene (debido a la transición con la etiqueta $sr!c$).


\begin{definition}[Eventos] Dados un conjunto de participantes $\mathcal{P}$ y un conjunto de mensajes $\mathcal{M}$ definimos un evento e como:
\begin{itemize}
    \item e = $(q_s, q_r, s, r, a)$ = $(q_s, q_r, s \rightarrow r:a)$ tal que $s, r \in   \mathcal{P}$ son CFSMs  
\end{itemize}
\end{definition}

Un evento e es una tupla $(q_s, q_r, s, r, a)$, también escrita como $(q_s, q_r, s \rightarrow r:a)$ indica que s y r se pueden intercambiar el mensaje a, cuando están en el estado $q_s$ y $q_r$, respectivamente. Para distinguir el paralelsimo a nivel máquina introducimos una relación de equivalencia sobre eventos que identifica eventos cuyas transiciones son $\blacklozenge$-equivalentes. 

\begin{definition}[Equivalencia entre eventos] Definimos la equivalencia entre eventos como $\bowtie = \bowtie_s \cap \bowtie_r \subseteq \mathcal{E} \times \mathcal{E}$ donde $\mathcal{E}$ es el conjunto de eventos del sistema y se cumplen las siguientes condiciones

\begin{itemize}
\item $(q_1, q_2, s \rightarrow r:a) \bowtie_s (q'_1, q'_2, s \rightarrow r:a) \iff \\ 
\forall (q_1, SR!a,q_3),(q'_1, SR!a,q'_3) \in \delta_s:(q_1, SR!a,q_3) \underline{\blacklozenge} (q'_1, SR!a,q'_3)  $
\item $(q_1, q_2, s \rightarrow r:a) \bowtie_r (q'_1, q'_2, s \rightarrow r:a) \iff \\ 
\forall (q_2, SR?a,q_3),(q'_2, SR?a,q'_4) \in \delta_r:(q_2, SR?a,q_4) \romboeqn (q'_2, SR?a,q'_4)$ \end{itemize}
\end{definition}

\begin{definition}[Sistema de transición sincrónico] Dados un sistema $S = (M_P)_{p \in \mathcal{P}}$, sean \\ $N = \{\overrightarrow{q} \ | \ (\overrightarrow{q}; \overrightarrow{\epsilon}) \in RS_1(S) \}$, \  $\hat{\delta}= \{(n, e, n') \ | \ (n;\overrightarrow{\epsilon}) s_1 \overset{sr!a}{\rightarrow}\overset{sr?a}{\rightarrow} (n';\overrightarrow{\epsilon})	\land e= n[s], n[r], s \rightarrow r:a	 \} $ \\ y $ E = \{ \exists n, n' \in N : (n,e,n') \in \hat{\delta}\} \subseteq \mathcal{E}$ el sistema de transición sincrónico de S es $TS(S)= (N, n_0, E/\bowtie,\rightharpoonup)$ donde $n_0= \overrightarrow{q_0} $ es el estado inicial, $n \overset{[e]}{\rightharpoonup} n' \iff (n,e,n') \in \hat{\delta}$. Fijamos un conjunto $\hat{E}$ de elementos representativos de cada clase de equivalencia $\bowtie$  $(ej: \hat{E} \subseteq E \ \mathit{y} \ \forall e \in E, \ \exists!e' \in \hat{E} : e' \in [e] $) y escribimos $n \overset{e'}{\rightharpoonup} n'$ para $ n \overset{[e]}{\rightharpoonup} n'$ cuando $ e' \in [e] \cap \hat{E} $. Las secuencias de eventos se notan con un símbolo $\pi$ y extendemos la notación de $ \rightarrow$ en la \cite[Def.~XXX]{sts} a $\rightharpoonup$ (ej: $si \pi = e_1 ...e_k, n_1 \overset{\pi}{\rightharpoonup} n_{k+1} sii n_1 \overset{e_1}{\rightharpoonup} n_2 \overset{e_2}{\rightharpoonup}...\overset{e_k}{\rightharpoonup} n_{k+1}$).

$TS(S)$ representa todas las posibles ejecuciones sincrónicas del sistema $S$; y cada transición es etiquetada con un evento $e$.
\end{definition}

\begin{definition}[Proyecciones] La proyección de un evento e sobre un participante p, denotado por $e \downharpoonright_p$ se define de la siguiente manera:

\begin{equation}
(q_s,q_r,s \rightarrow r:a) \downharpoonright_p = \begin{cases} 
pr!a & \mathit{if} s=p \\
sp?a & \mathit{if} r=p \\
\epsilon & \mathit{en \ otro \ caso} \\
\end{cases} 
\end{equation}

La proyección se define sobre secuencias de eventos en el modo obvio. La proyección $TS(S)= (N, n_0, \hat{E}, \rightharpoonup)$ sobre el participante p, notada $ TS(S) \downharpoonright_p $, es el autómata $(Q, q_0, \mathit{Act}, \delta)$ donde $Q=N, \ q_0 = n_0$, Act es el conjunto de etiquetas y $\delta \subseteq Q \times Act \cup \{ \epsilon \} \times Q $ es s.t. $(n_1, e \downharpoonright_p, n_2) \in \delta \iff n_1 \overset{e}{\rightharpoonup} n_2 $

\end{definition}

Introducimos el concepto de generalized multiparty compatibility (GMC) como una condición completa y sólida para construir CFSMs. 
% Usé sólida como traducción de sound. En el paper habla de construir global graphs, término que acá no usamos, no se si puse bien
A partir de este punto, fijamos un sistema $S =(M_p)_{p \in \mathcal{P}} $ con $TS(S)= (N, n_0, \hat{E}, \rightharpoonup)$. GMC depende de dos condiciones, representabilidad y propiedad de ramificación. La primera determina que para cada máquina, cada traza y cada elección estén representadas. La segunda, que cada vez que hay una decisión en un sistema TS(S), una única máquina toma esa decisión y cada uno de los otros participantes es notificado de la rama que se tomó o no participa en esa elección. Representabilidad garantiza que TS(S) contiene suficiente información para decdir propiedades seguras de cualquier ejecución asincrónica de S. La propiedad de ramificación asegura que si una rama en TS(S) representa una elección esta está "bien formada". \cnote{Nota de Eze: es esto lo que pedís en la nota abajo?}


\begin{definition}Para un lenguaje $\mathcal{L}$, $hd(\mathcal{L})$ devuelve las primeras acciones de $\mathcal{L}$ si las tiene: 
\begin{center}
$hd(\mathcal{L})= \{\ell \ | \ \exists q \in Act*: \ell \cdot q \in \mathcal{L} \}$	\ \	 $hd(\{ \epsilon \}) = \{ \epsilon \}$
\end{center}

Dado $n \in N$, sea $ TS(S)\langle n \rangle$ el sistema de transición TS(S) donde se reemplaza al estado inicial $n_0$ por $n$. Escribimos LT(S,n,p) para $\mathcal{L}(TS(S)\langle n \rangle)\downharpoonright_p $, es decir LT(S,n,p) es el lenguaje que se obtiene estableciendo a n como nodo inicial de TS(S) y proyectando el nuevo sistema de transición sobre p.

\end{definition}

\cnote{Agregar intuición sobre qué dicen las definiciones y para que serán usadas. Ayuda al lector a seguir el trabajo.}

\begin{definition}[Representabilidad]Un sistema S es representable si
\begin{enumerate}
\item $\mathcal{L}(M_p) = LT(S,n_0,p) $ y
\item $\forall q \in Q_p \ \exists n \in N: n[p] = q \land  \cup_{(q,\ell, q') \in \delta_p} \{ \ell \} \subseteq hd (LT(S,n,p))$
\end{enumerate}
para todo $p \in \mathcal{P} $ \\
La primera condición es necesaria para asegurar que cada traza de cada máquina esté en TS(S). La segunda condición es necesaria para asegurar que cada elección en cada máquina esté representada en TS(S).
\end{definition}

\begin{definition}[Propiedad de ramificación] Un sistema S posee la propiedad de ramificación si para todo $n \in N$ y para todo $e_1 \neq e_2 \in \hat{E} \ \mathit{tq} \ n \overset{e_1}{\rightharpoonup} n_1 \ \mathit{y} \  \ n_1 \overset{e_2}{\rightharpoonup} n_2$ luego tenemos
\begin{enumerate}
\item o bien existe $n'\in N$ tal que $n_1 \overset{e_2}{\rightharpoonup} n' \ \mathit{y} \ n_2 \overset{e_1}{\rightharpoonup} n'$, o 
\item para cada $(n'_1, n'_2) \in ln(n, e_1, e_2)$ quedando 

$L_p^i = hd (\{e_i \downharpoonright_p \cdot \phi \  | \ \phi \in LT(S,n'_i,p) \} ) $ con $i \in \{1,2\}$ y $p \in P$, y se cumplen las condiciones 2a, 2b y 2c definidas abajo 	

\begin{enumerate}[(a)]
\item Choice awareness: $\forall p \in \mathcal{P}$ valen \begin{enumerate}[i.]
\item $L_p^1 \cap	L_p^2 \subseteq \{ \epsilon \} \ \mathit{y} \  \epsilon \in L_p^1 \iff \epsilon \in L_p^2$, o 
\item $\exists n' \in N, \pi_1, \pi_2$: $n'_1 \overset{\pi_1}{\rightharpoonup} n' \land  n'_2 \overset{\pi_2}{\rightharpoonup} n' \land (e_1 \cdot \pi_1) \downharpoonright_p= (e_2 \cdot \pi_2)\downharpoonright_p = \epsilon$
\end{enumerate}
\item selector único: $\exists!s \in \mathcal{P}: L_s^1 \cap L_s^2 = \emptyset \land \exists sr!a \in L_s^1 \cup L_s^2 $
\item no race: $\forall r \in \mathcal{P}: L_r^1\cap L_r^2 = \emptyset \Rightarrow \forall s_1r?a_1 \in L_r^1, \forall s_2r?a_1 \in L_r^2:\forall i \neq j \in \{1,2\}: n'_i \overset{\pi_i}\rightharpoonup  $ \\
$\Rightarrow dep (s_i \rightarrow r: a_i, e_i \cdot \pi_i, s_j \rightarrow r: a_j) $
\end{enumerate}

\end{enumerate} 	

\end{definition}
Con esto definimos que toda ramificación es o bien (1) la ejecución concurrente de dos eventos; o, para cada participante p (2(a)I) si p no termina antes de n entonces las primeras dos acciones de p en dos ramas distintas son disjuntas; o (2(a)II) p no está involucrado en la elección, o sea la ramas se juntan antes de que p realice ninguna acción; (2(b)) hay un único participante s tomando la decisión; y (2(c)) para cada participante r involucrado en la elección, no puede haber race condition entre los mensajes que puede recibir r. La no race condition asegura que en ninguna ejecución (asincrónica) de S, si una máquina tiene más de un buffer no vacío, entonces puede leerlos en cualquier orden (interleaving es posible). Notar que si una máquina r recibe todos sus mensajes de un mismo emisor, entonces hay una $\triangleleft$-relación entre todas sus acciones.

\begin{definition}[General Multiparty Compatibilty] Un sistmea S es generalised multiparty compatible (GMC) si es representable y posee la propiedad de ramifiación. 
\end{definition}


\section{Composición Parcial de Compponentes Asincrónicas}
\subsection{Motivación}

 En SOC (service oriented computing) el objetivo es que los servicios se obtengan por demanda. Es decir un sistema de este tipo utiliza distintos servicios según la necesidad. Esto nos da la idea binding incremental, dado que a medida que se vayan necesitando distintas funciones, el sistema va agregando servicios con los cuales se conecta. Por otro lado existe un procedimiento para determinar si un conjunto de CFSMs puede interactuar entre sí sin errores. El problema es que este procedimiento necesita tener a mano las CFSMs para cada uno de los participantes de la comunicación. Esto va en contra de la idea de conectarse a servicios en tiempo de ejecución. Para modelar esto necesitamos un tipo de autómatas que soporten la composición parcial. Al componer dos CFSMs puede ocurrir que cada máquina se comunique a través de un canal con un tercer participante. Estos canales son independientees en el sentido de que son diferentes buffers FIFO. Por lo tanto para preservar la semánitica es necesario que el autómata resultante de la composición tenga dos canales con este tercer participante. Para modelar este comportamiento introducimos los Autómatas Finitos de Comunicación Asincrónica (AFCA). Estos autómatas tienen tres tipos de transiciones: internas que representan procesamiento propio; de buffer que representan comunicación asincrónica interna y permiten representar la comunicación entre dos participantes luego de una composición; y por último transiciones que modelan acciones de comunicación externa como en CFSMs.

\subsection{Autómatas finitos de comunicación asincrónica}

\begin{definition}[Cola]
\label{def:cola}
Una cola es un tipo de estructura de datos caracterizada por ser una secuencia de elementos first in-first out (FIFO) debido a que el primer elemento en entrar es el primer elemento en salir. Para manejarla se definen dos operaciones, una para agregar y otra para sacar elementos de la una cola. Para los usos de este trabajo vamos a definir colas en las cuales se depositan y de las cuales se retiran mensajes, con las operaciones:

\begin{itemize}
\item Cola vacía: denotado $[\ ]$
\item Encolar mensaje: denotado como $b \ll m$, si $b$ es una cola y $m$ es un mensaje.
\item Desencolar mensaje: denotado como $b \gg m$, si $b$ es una cola y $m$ es un mensaje.
\item Sea una cola vacía $b= [\ ]$ al aplicarle la operación $b \ll m$ queda $b= [m]$
\item Sea una cola no vacía $b= [m_1,..,m_n]$ al aplicarle la operación $b \ll m$ queda $b= [m,m_1,..,m_n]$ del mismo modo al aplicarle $b \gg m_n$ queda $b= [m,m_1,..]$
\end{itemize}
\end{definition}

\begin{definition}[Autómata finitos de comunicación asincrónica]
\label{def:aa}
Sea $\mathcal{P}$ un conjunto de participantes y $\mathcal{M}$ un conjunto de mensajes. Un \emph{autómata finitos de comunicación asíncrona} es una estructura $A_\mathcal{P} = \langle Q, B, \mathcal{C}, \Sigma, \delta, q_0, F\rangle$ tal que:

\begin{itemize}
\item $Q$ es un conjunto finito de estados,
\item $B \subseteq \{pq_n \ | \ pq \in \mathcal{P}^2, n \in \mathbb{N}, p \neq q \} $ es un conjunto finito de buffers (i.e. colas, ver Def.~\ref{def:cola}),
\item $\mathcal{C} \subseteq \{pq_n \ | \ pq \in \mathcal{P}^2, n \in \mathbb{N}, p \neq q \}$ es un conjunto de canales tales que $B \cap \mathcal{C} = \emptyset$ 
\item $\Sigma = \{ \Sigma_\mathit{Int} \cup \Sigma_\mathit{Ex} \cup \Sigma_\mathit{Buff}\} $, $\Sigma \cap \mathcal{M} = \emptyset$ es el conjunto de etiquetas del autómata, siendo
\begin{inparaenum}[1)]

\item $\Sigma_\mathit{Int}$ las acciones internas del autómata 

\item $\Sigma_\mathit{Ex}$ un conjunto de etiquetas de la forma $\langle p_1,p_2,c\rangle$ dónde $p_1,p_2 \in \mathcal{P}$ son, respectivamente, el emisor y el receptor de la comunicación y $c \in \mathcal{C}$ es el canal a través del cual se resuelve la misma.
%\item $\forall (p_1,P_2,c), (p'_1,P'_2,c') \in \Sigma_{Ex} c = c' \iff p_1= P'_1 \land p_2= P'_2 $

\item $\Sigma_\mathit{Buff}$ es el conjunto de etiquetas de las acciones sobre los buffers de la forma $b \ll m$ o $b \gg m$, dónde $b \in B$ y $m \in \mathcal{M}$.
\end{inparaenum}
\item $\delta = (\delta_\mathit{Int} \cup \delta_\mathit{Ex} \cup \delta_\mathit{Buff})$ siendo:

\begin{inparaenum}[1)]
\item $\delta_\mathit{Int} \subseteq Q \times \Sigma_\mathit{Int} \times Q$ es la relación de transicion por acciones internas de $A_\mathcal{P}$, %transiciones internas

\item $\delta_\mathit{Ex} \subseteq Q \times \{\mathit{In}(c,m), \mathit{Out}(c,m) | c \in \Sigma_{Ex} \land m \in \mathcal{M} \} \times Q$ es la relación de transición de comunicación externa de $A_\mathcal{P}$, %comunicación externa

\item $\delta_\mathit{Buff} \subseteq Q \times \Sigma_\mathit{Buff} \times Q$ %comunicación interna
\end{inparaenum}
\item $q_0 \in Q$ es el estado inicial, y
\item $F \subseteq Q$ es el conjunto de estados finales. 
\end{itemize}

Se denota $P(A)$, al conjunto de participantes que integran el autómata A, y se define como $P(A) = \{ p \in \mathcal{P} \ | (\exists\ \langle p1,p2,c\rangle \in \Sigma_\mathit{Ex})(p1=p \lor p2=p) \} $ 
\end{definition}


Explicación de la intuición de la definición.

$\Sigma$ es el conjunto de todas las etiquetas del autómata y lo dividimos en tres subconjuntos disjuntos que la forman $\Sigma_{\mathit{Int}}$, $\Sigma_{\mathit{Ex}}$ y $\Sigma_{\mathit{Buff}}$ que corresponden a las acciones de procesamiento interno, las de comunicación externa con otros participantes y las de comunicación interna vía buffers.

$\Sigma_{Ex}$ es el conjunto de etiquetas correspondientes a la comunicación externa del autómata. Como la comunicación es dirigida punto a punto, cada etiqueta incluye a dos participantes $p_1, P_2 \in \mathcal{P}$ (emisor y receptor) y un canal $c \in \mathcal{C}$. Necesariamente en todas las etiquetas vale que $p_1$ y $p_2$ son distintos y .

$\Sigma_{Buff}$ es el conjunto de etiquetas de acciones de comunicación interna vía buffers. Se especifican las acciones de encolar y desencolar como $b \ll m$, $b \gg m$, respectivamente, donde $b \in B$ y $m$ es el mensaje que se inserta/extrae del mismo.

$\delta$ es el conjunto de transciciones que se compone de $\delta_{Int}$, las acciones internas, $\delta_{Ex}$ las transiciones de comunicación con otros agentes y $\delta_{Buf}$ las acciones de buffer.

$\delta_{Ex}$ se compone de dos tipos de acciones denotadas \textit{In(c,m)} y \textit{Out(c,m)}, con $c \in \Sigma_{Ex}$ y $m \in \mathcal{M}$ . Las acciones de entrada o input que representan la recepción de un mensaje de algún proceso externo al correspondiente al autómata,  y las acciones de output o salida que representan el envío de un mensaje y se denotan. Estas acciones son la parte externa de la comunicaión asincrónica. Como los canales son unidireccionales decimos que para todo par de participantes existen dos canales, uno por cada sentido.

$\delta_{Buff}$ es la relación de transición de comunicación interna mediante buffers.\\

Formalmente, F $\subseteq$ Q. Es el conjunto de estados finales, los posibles estados a los que una ejecución llega y es aceptada como válida. Para los autómatas asincrónicos pedimos también que al llegar a este estado final los buffers se encuentren vacíos. Para esto definimos lo siguiente:

\begin{definition}[Configuración instantánea]
Dados $\mathcal{P}$ un conjunto de participantes y $\mathcal{M}$ un conjunto de mensajes. A un autómata con comunicación asincrónica $A_\mathcal{P} = \langle Q, B, \mathcal{C}, \Sigma, \delta, q_0, F\rangle$, definimos:

Una configuración instantánea del autómata como $\langle q, \Omega \rangle \in Q \times \{ [m_b]_{b \in B} | m_b \in \mathcal{M}^* \}$ donde $\mathcal{M}^* = \{ [s_o, \ldots, s_n] \  | \ \forall i \in [0, \ldots, n], s_i \in \mathcal{M} \}$ y $[m_b]_{b \in B} $

\begin{itemize}
\item  q es es el estado actual
\item $\sigma$ es la secuencia de acciones por realizar, y
\item $\Omega$ es la secuencia de buffers (con sus respectivos contenidos hasta el momento). Decimos que $\Omega$ es de la forma $[ \omega_{b_1}, \omega_{b_2},..., \omega_{b_n} ]$ con $b_i \in B$. 
\item Decimos que una configuración es inicial si $q = q_0$ y $ \Omega = [ [], \ldots, [] ]$
\item Decimos que una configuración es final si $q \in F$ y $ \Omega = [ [], \ldots, [] ]$
\end{itemize}
\end{definition}

\begin{definition}[Relación de transición entre configuraciones] Sean $A_\mathcal{P} = \langle Q, B, \mathcal{C}, \Sigma, \delta, q_0, F\rangle$, $q_1, q_2 \in Q$, $ m \in \mathcal{M}$ definimos $\vdash$, relación de transición entre configuraciones, como:  
\begin{enumerate}
\item $(q_1, \Omega) \vdash (q_2, \Omega) \iff \langle q_1,r, q_2 \rangle \in \delta \land r \in \Sigma \setminus \Sigma_\mathit{Buff}$

\item $(q_1 ,[\omega_{b_1},\ldots,\omega_{b_i},\ldots,\omega_{b_n}]) \vdash (q_2,[\omega_{b_1},\ldots,m : \omega_{b_i},\ldots,b_n]) \iff \langle q_1, b_i \ll m, q_2 \rangle  \in \delta $ 

\item $(q_1, [\omega_{b_1},\ldots,\omega_{b_i} : m,\ldots,\omega_{b_n}]) \vdash (q_2,[\omega_{b_1},\ldots,\omega_{b_i},\ldots,\omega_{b_n}]) \iff \langle q_1, b_i \gg m, q_2 \rangle \in \delta$
\end{enumerate}

\end{definition}

\begin{definition}[Traza de un ACFSA] Llamamos traza a una secuencia posible de acciones de un autómata. Se define como una secuencia finita de etiquetas de estado y transición altenradas, que comienza y termina con un estado. Dado un autómata $A_\mathcal{P} = \langle Q, B, \mathcal{C}, \Sigma, \delta, q_0, F\rangle$, una traza tiene las siguientes caracterísitcas

\begin{itemize}
\item Tiene la forma $[q_0, \sigma_1, q_1,...,q_{n-1}, \sigma_n, q_n] $ donde 
\item $q_0$ es el estado inicial del autómata
\item $q_i \in Q$,
\item $ \sigma_i \in \Sigma$ y
\item $\langle q_{i-1}, \sigma_i, q_i \rangle \in \delta $ 
\end{itemize}

El comportamiento de un ACFSA es el conjunto de todas las trazas posibles.
\end{definition}

\begin{definition}[Ejecución de un ACFSA]. Una ejecución es un $ \tau = \tau_0, \ldots,\tau_n $ donde $\tau_0$ es la configuración inicial, $\langle \tau_i, \tau_{i+1} \rangle \in \vdash$, $\tau_n$ es una configuración final y $ \forall i \in [1, \ldots, n], \tau_i$ es una configuración. Una ejecución es una configuración que no entra en deadlock, mensajes huérfanos ni receptor no especificado.


\end{definition}


% \begin{definition}[Condición de aceptación] Sea $\sigma$ una secuencia de transiciones sobre $A_{\mathcal{P}}$, decimos que es una ejecución válida si se cumple lo siguiente:

% \centering
% $\sigma \in E(A_{\mathcal{P}}) \iff \exists q_f \in F \ | \  (q_0, \sigma, [[],..,[]]) \vdash^*(q_f, \emptyset, [ [],..,[] ])$ 
% \end{definition}


% Entonces decimos que una ejecución aceptable es aquella que cumple que en una cantidad finita de pasos llegó a un estado final con los buffers vacíos, asegurándonos la ausencia de mensajes huérfanos y deadlocks.

\begin{definition}[Deadlock]Sean $A_\mathcal{P} = \langle Q, B, \Sigma, \delta, q_0, F\rangle$, $q_{i} \in Q$, $\sigma \in \Sigma^*$,  $\Omega = [ \omega_{b_1},..,\omega_{b_i},..,\omega_{b_n} ]$, decimos que una configuración está en deadlock cuando ocurre:
\begin{itemize}
\item En la configuración $\langle q_i, \Omega \rangle$,

\item $ \forall \langle q_i, s, q_j \rangle \in \delta$, $s \in \Sigma_\mathit{Buff} \land (s= b \gg m \Rightarrow \omega_b = [\ ])$
\end{itemize}
\end{definition}

Decimos que ocurre deadlock cuando partiendo de un estado la única transición posible hacia un estado siguiente es consumiendo un mensaje de algún buffer y esos buffers se encuentran vacíos.  \\

\begin{definition}[Mensajes huérfanos]Sean $A_\mathcal{P} = \langle Q, B, \Sigma, \delta, q_0, F\rangle$, $q_{i} \in Q$, $\sigma \in \Sigma^*$,  $\Omega = [ \omega_{b_1},..,\omega_{b_i},..,\omega_{b_n} ]$, decimos que una configuración tiene mensajes huérfanos cuando ocurre:
\begin{itemize}
\item En la configuración $\langle q_i, \Omega \rangle$ ,

\item $ \exists \omega_{b} \in \Omega \ | \ \omega_b \neq [\ ] $

\item $ \delta(q_i) = \emptyset  $
\end{itemize}
\end{definition}

Decimos que la configuración tiene mensajes huérfanos si, en un estado $q_i$  quedan mensajes sin consumir en algún buffer y no hay ninguna transición saliente. 


\begin{definition}[Receptor no especificado]Sean $A_\mathcal{P} = \langle Q, B, \Sigma, \delta, q_0, F\rangle$, $q_{i} \in Q$, $\sigma \in \Sigma^*$,  $\Omega = [ \omega_{b_1},..,\omega_{b_i},..,\omega_{b_n} ]$ decimos que una configuración es de receptor no especificado cuando ocurre:
\begin{itemize}\item En la configuración $\langle q_i, \Omega \rangle$ ,

\item $ \exists \omega_{b} \in \Omega \ | \ \omega_b \neq [\ ] $

\item $ \forall \langle q_i, s, q_j \rangle \in \delta$, $s \in \Sigma_\mathit{Buff} \land (s= b \gg m \Rightarrow \omega_b = [\ ] \lor \omega_b = [ \ldots, m' ], m' \neq m )$
\end{itemize}
\end{definition}

\begin{definition}[Estados alcanzables]

\end{definition}

La Figura~\ref{fig:ejemplo-aa} muestra un ejemplo de estos autómatas.

\begin{figure}[ht]
\begin{center}
Dibujo
\end{center}
Explicación en castellano del ejemplo
\caption{Ejemplo de autómata asíncrono de comunicación}
\label{fig:ejemplo-aa}
\end{figure}


Como la idea es que los autómatas con comunicación asincrónica reperesenten procesos o servicios que pueden formar parte de un sistema más grande, necesitamos definir la operación de composición. Para que un par de autómatas E y R sean compatibles para la composición debemos pedirlas siguientes condiciones

 \begin{enumerate}
\item $\Sigma_E \cap \Sigma_R = \emptyset$ el conjunto de etiquetas debe ser disjunto, tanto internas, como de entrada/salida y de bufffer
\item $ B_E \cap B_R = \emptyset$ el conjunto de Buffers de ambos autómatas debe ser disjunto  
\end{enumerate}

\begin{definition}[Composición]
Dados $\mathcal{P}$ un conjunto de participantes y $\mathcal{M}$ un conjunto de mensajes. Dos autómatas  $E_\mathcal{P} = \langle Q_E, B_E, \mathcal{C}_E. \Sigma_E, \delta_E, q_{0E}, F_E\rangle$ y $R_\mathcal{P} = \langle Q_R, B_R, \mathcal{C}_R, \Sigma_R, \delta_R,  q_{0R}, F_R\rangle$, que cumplan $\Sigma_E \cap \Sigma_R = \emptyset$ y $ B_E \cap B_R = \emptyset$, definimos la composición $E||R_\mathcal{P}$ componente a componente.

\begin{itemize}
\item $Q_{ER} = Q_E \times Q_R$ El conjunto de estados de la composición es el producto cartesiano de los estados de los autómatas componentes. 

\item $B_{ER} = B_E \cup B_R \cup \{\mathcal{C}_{E} \cap \mathcal{C}_{R}\}$ es el conjunto de nombres de buffers del autómata resultante.Se compone de los buffers internos de ambos autómatas junto con uno nuevo por cada canal compartido entre ambos autómatas. Los canales compartidos son aquellos mediante los cuales los autómatas a componer intercambian mensajes entre sí.

\item $\mathcal{C}_{ER}= \{ \mathcal{C}_{E} \cup \mathcal{C}_{R} \} \setminus \{ \mathcal{C}_{E} \cap \mathcal{C}_{R} \}$

\item $\Sigma_{ER} = (\Sigma_{\mathit{ERInt
}} \cup \Sigma_{\mathit{EREx}} \cup \Sigma_{\mathit{ERBuff}})$ tal que: \begin{inparaenum}[1)]


\item $\Sigma_{\mathit{ERInt}} = \Sigma_{\mathit{EInt}} \cup \Sigma_{\mathit{RInt}} $,

\item $\Sigma_{\mathit{EREx}} = \Sigma_{\mathit{EEx}} \cup \Sigma_{\mathit{REx}} \setminus \Sigma_\mathit{EfromtoR} $ y 

\item $\Sigma_{\mathit{ERBuff}} = \Sigma_{\mathit{EBuff}} \cup \Sigma_{\mathit{RBuff}} \cup \Sigma_\mathit{EfromtoR}$ donde

\item $\Sigma_\mathit{EfromtoR} =\{ \langle p_1,p_2,c \rangle \ | \ p_1,p_2 \in \mathcal{P}, \  c \in \mathcal{C} \ y \ ((p_1 = E \land p_2 = R) \lor (p_1 = R \land p_2 = E))   \} $
\end{inparaenum}
\item $\delta_{ER} = \{ \delta_{ER \mathit{Int}} \cup \delta_{ER\mathit{Ex}} \cup \delta_{ER\mathit{Buf}}\}$
\item $\delta_{ER\mathit{Int}} = Q_{ER} \times \Sigma_{ER\mathit{Int}} \times Q_{ER} $
\item $\delta_{ER\mathit{Ex}}: Q_{ER} \times \{\mathit{In}(e,m), \mathit{Out}(e,m) | e \in \Sigma_{ER\mathit{Ex}} \land m \in \mathcal{M}\} \times Q_{ER}$ es la relación de transición de comunicación externa de $E||R_\mathcal{P}$,
\item $\delta_{ER\mathit{Buf}}: Q_{ER} \times \Sigma_{ER\mathit{Buf}} \times Q$ y decimos que $\forall q \in Q_\mathit{ER}, \ m \in \mathcal{M} \ | \ \langle q, \omega_\mathit{ERi} \gg m, q' \rangle \in \delta_\mathit{ERBuff} \iff \exists \sigma_i \in s \land \sigma_i = \omega_\mathit{ERi} \ll m$  donde s es una secuencia de la forma $[q_1, \sigma_1, q_2,...,\sigma_n, q_n]$ con $q_n = q$% comunicación interna
\item $q_0 = \langle q0_E,q0_R \rangle$
\item $F_{ER} = F_E x F_R$

\end{itemize}
\end{definition}


Explicación de la intuición de definición \\

Cada autómata es un sistema independiente que cumple una función (o una serie de funciones), y se relaciona con otros a través del envío de mensajes. Decimos que si dos autómatas tienen una acción con la misma etiqueta, al componerlos, ambas transsiciones se ejecutarían a la par. Como estos autómatas son de comunicación asincrónica, queremos evitar que dos transiciones se sicronizen de ese modo. Para asegurarnos esto pedimos que todo par de autómatas a componerse tengan conjuntos de etiquetas de acciones que sean disjuntos. Formalmente que dados E y R, $\Sigma_E \cap \Sigma_R = \emptyset$. \\

Del mismo modo, cada autómata tiene su propio conjunto de buffers que pedimos sean disjuntos, para distinguir la comunicación interna de cada autómata componente de la que ocurra entre componentes o con participantes externos. Para modelar la comunicación interna entre componentes, agregamos dos buffers, uno para cada sentido de la comunicación, de E a R y viceversa.\\

Como los conjuntos de acciones son disjuntos podemos decir que las acciones internas, de comunicación externa y de buffer, de cada componente se preservan, siempre y cuando tenga sentido con la composición de estados. Existe un caso particular que ocurre cuando existían envíos de mensaje de un autómata componente a otro. En ese caso dado que ambos ahora son parte un mismo autóamta, la comunicación pasa a ser envío de mensajes interno. Para representar este tipo de comunicación es que utilizamos buffers. De este modo el intercambio que antes era In((E,R,c),m) y Out((E,R,c),m) ahora es $b_{ER}  \ll m$ y $b_{ER}  \gg  m$, donde $ b_{ER} \in \{ \mathcal{C}_E \cap \mathcal{C}_R \} $ son los buffers exclusivos del autómata compuesto. \\

Al componer dos autómatas la comunicación que antes era externa y ahora es de buffer puede generar problemas. Puntualmente pueden aparecer transiciones de consumo de un buffer (que antes eran envío de mensajes) donde antes no había. De este modo pueden aparecer secuencias de estados y transiciones donde se consume un mensaje antes de que este sea depositado en el buffer correspondiente. Para esto pedimos que $\delta_\mathit{ERBuff}$ cumpla con una condición especial. Solo pueden haber transiciones de consumo saliendo de un estado si en alguna secuencia de acciones que termina en ese estado, hay transiciones de producción (es decir se encola un mensaje en el buffer).

La composición es conmutativa y se puede generalizar a una cantidad arbitraria (finita) de autómatas.



La Figura~\ref{fig:ejemplo-aa} muxestra un ejemplo de una composición de dos autómatas. 

\begin{figure}[ht]
\begin{center}
Dibujo
\end{center}
\caption{Ejemplo de composición autómata asíncrono de comunicación}
\label{fig:ejemplo-aa}
\end{figure} 

\begin{definition}[Determinismo] Decimos que un autómata es determinístico cuando cumple que no hay dos transiciones con la misma etiqueta que partan de un mismo estado y vayan a estados distintos. Es decir 

\begin{centering}
Sea un autómata $ \Lambda = \langle Q, \Sigma, \delta, q_0, F \rangle$ se cumple
$ \forall \  q_i, q_j, q_k \in Q_{j \neq k}, \  \nexists \ \delta_i, \delta_j \in \delta, t \in \Sigma \ \| \  \delta_1 = \langle q_i, t, q_j \rangle, \ \delta_2 = \langle q_i, t, q_k \rangle$ \\
\end{centering} 

Decimos que la composición de estos autómatas preserva el determinismo. Esto es un resultado directo de que ambos autómatas no comparten acciones y de la definición de la composición de $\delta$.

\end{definition}


% \begin{definition}[Autómata proyectado] Dados, un conjunto de participantes $\mathcal{P}$, un conjunto de mensajes $\mathcal{M}$, un autómata $A = \langle Q, \mathcal{C}, B, \Sigma, \delta, q_0, F\rangle$, y una configuración instantánea del mismo $\langle q_{i}, \Omega_i \rangle$, $q_i \in Q, \Omega_i \in B^*$ llamamos autómata proyectado $A_{\pi}= \langle Q_{\pi}, \beta, \mathcal{C}_{\pi}, \Sigma_{\pi}, \delta_{\pi}, q_i, F\rangle$ al autómata resultante de recortar A a partir de $q_i$. Donde:
% \begin{itemize}
%     \item $Q_{\pi} = \{q \in Q \ | \  \exists \omega \in B^*,$ tq $\langle q_{i}, \omega_i \rangle \vdash^* \langle q, \omega \rangle  \}$ son aquellos estados alcanzables desde $q_i$
%     \item $ \beta \subseteq B $ son los buffers del autómata. Los buffers retienen aquellos mensajes que fueron almacenados pero aún no han sido retirados en $q_i$
%     \item $\mathcal{C}_{\pi}$ es el conjunto de canales de comunicación externa
%     \item $\Sigma_{\pi}=  \{ \gamma \in \Sigma \ | \ \exists q_k, q_l \in Q' \land \langle q_k ,\gamma, q_l \rangle \in \delta \}$ es el conjunto de etiquetas del autómata proyectado y se compone de aquellas etiquetas 
% %     $\{ \Sigma_\mathit{Int} \cup \Sigma_\mathit{Ex} \cup \Sigma_\mathit{Buff}\} $, $\Sigma \cap \mathcal{M} = \emptyset$ es el conjunto de etiquetas del autómata, siendo
% %     \begin{inparaenum}[1)]

% %         \item $\Sigma_\mathit{Int}$ las acciones internas del autómata 

% %         \item $\Sigma_\mathit{Ex}$ un conjunto de etiquetas de la forma $\langle p_1,p_2,c\rangle$ dónde $p_1,p_2 \in \mathcal{P}$ son, respectivamente, el emisor y el receptor de la comunicación y $c \in \mathcal{C}$ es el canal a través del cual se resuelve la misma.

% %         \item $\Sigma_\mathit{Buff}$ es el conjunto de etiquetas de las acciones sobre los buffers de la forma $b \ll m$ o $b \gg m$, dónde $b \in B$ y $m \in \mathcal{M}$.
% % \end{inparaenum}
% \item $\delta_{\pi} = \{  \}$
% % \item $\delta = (\delta_\mathit{Int} \cup \delta_\mathit{Ex} \cup \delta_\mathit{Buff})$ siendo:

% % \begin{inparaenum}[1)]
% %     \item $\delta_\mathit{Int} \subseteq Q \times \Sigma_\mathit{Int} \times Q$ es la relación de transicion por acciones internas de $A_\mathcal{P}$, %transiciones internas

% %     \item $\delta_\mathit{Ex} \subseteq Q \times \{\mathit{In}(c,m), \mathit{Out}(c,m) | c \in \Sigma_{Ex} \land m \in \mathcal{M} \} \times Q$ es la relación de transición de comunicación externa de $A_\mathcal{P}$, %comunicación externa

% %     \item $\delta_\mathit{Buff} \subseteq Q \times \Sigma_\mathit{Buff} \times Q$ %comunicación interna
% % \end{inparaenum}    
% \item $q_i \in Q'$ es el estado inicial del autómata proyectado, 
%     \item $F \subseteq Q$ es el conjunto de estados finales del autómata.
% \end{itemize}

% \end{definition}


\subsection{Multichannel CFSM}
 Al principio de esta sección introdujimos los AFCA para modelar el comportamiento deseado en SOC de binding incremental. Ahora nos queremos enfocar en los aspectos puramente comunicacionales, es decir la interacción entre distintos participantes. Para hacer énfasis en estos aspectos existen las CFSMs, pero los AFCA introducen con la composición la posibilidad de que haya múltiples canales de comunicación entre dos participantes. En esta sección atendemos dicha problemática introduciendo las Multichannel Communicating Finite State Machines. Se definen, del mismo modo que una CFSM sobre $\mathcal{M}$ de la siguiente manera.

\begin{definition}[mCFSM] Una multichannel communicating finite state machine (mCFSM) sobre $\mathcal{M}$ es una un sistema finito de transición $(Q, \mathcal{C}, q_0, \mathcal{M}, \delta)$ donde
\begin{itemize}
  \item $Q$ es un conjunto finito de estados
  \item $\mathcal{C} = \{ pq_n \mid pq \in \mathcal{P}^2, n \in \mathbb{N}, p \not= q\}$ es un conjunto de canales
  \item $q_0 \in Q$ es el estado inicial;
  \item $\delta \subseteq Q \times (\mathcal{C} \times \{!,?\} \times \mathcal{M}) \times
    Q$ es un conjunto finito de \emph{transiciones}.
  \end{itemize}

Un communicating system es un mapa S que asigna un mCFSM S(p) a cada $p \in \mathcal{P}$. Escribimos $q \in S(p)$ cuando q es un estado de la máquina S(p) y $\tau$ es una transición de S(p).
  
Al igual que antes la semántica de un communicating system se obtiene considerando configuraciones. Estas configuraciones son iguales a las de las CFSM puras con la salvedad que ahora los canales no están restringidos a un único par entre cada par de participantes.

 \end{definition}
 
% * <ivissani@gmail.com> 2018-01-28T13:14:43.225Z:

% De esta manera lo que tenés es una enumeración de canales entre cada par de participantes. Lo único que hay que hacer es ajustar la semántica (las reglas) a esta nueva notación para que sea coherente.
% 
% Notar que la cantidad de canales existentes entre cada par de participantes ahora es infinita (los naturales) PERO la cantidad de ellos que vas a usar siempre va a ser finita porque de acuerdo a la notación que tenemos hay que fijar qué canal se usa en cada envío/recepción de mensaje y, por lo tanto, el hecho de que EXISTAN infinitos canales no afecta a la semántica ni al poder expresivo de las CFSMs
% 


\begin{definition}[Semántica de una mCSFSM]La configuración de un multichannel communicating system se define en términos de transiciones entre configuraciones como se ve a continuación:

  La configuración de un communicating system S es un par
  $s = \sysconf{q}{w}$ donde
  $\vectorize{q} = \left(q_\p\right)_{\p \in \mathcal{P}}$ donde
  $q_\p \in S(p)$ para cada $p \in \mathcal{P}$ y
  $\vectorize{w} = \left(w_{pq}\right)_{pq \in \C}$ con
  $w_{pq} \in \mathcal{M} $.
  
  Una configuración $s' = \sysconf{q'}{w'}$ es \emph{alcanzable} desde otra
  configuración $s = \sysconf{q}{w}$ a través de la \emph{ejecución de la
    transición}  $\tau $ (escrito $s \overset{t}{\rightarrow} s'$) si existe un
   $m \in \mathcal{M}$ tal que ocurre una de las siguientes alternativas:
	\begin{enumerate}
		\item $t = (q_p, pq_n!m,  q'_p) \in \delta_p$ y 
			\begin{enumerate}
				\item $q'_{p'} = q_{p'}$ for all $p' \neq p$; y
				\item $w'_{pq_n} = w_{pq_n} \cdot m$ and $w'_{p'q'_m} = w_{p'q'_m}$ for all $p'q'_m \neq pq_n$; \\
			\end{enumerate}
                O bien
		\item $t = (q_q, pq?m,  q'_q) \in \delta_q$ y 
			\begin{enumerate}
				\item $q'_{p'} = q_{p'}$ for all $p' \not= q$; y
				\item $m \cdot w'_{pq_n} = w_{pq_n}$ and $w'_{p'q'_m} = w_{p'q'_m}$ for all $p'q'_m \neq pq_n$
			\end{enumerate}
	\end{enumerate}
\end{definition}

Multichannel CFSMs  con un único canal para cada par ordenado de participantes son equivalentes a CFSMs puras.


\subsection{Aspectos comunicacionales de los AFCA}

Una de las desventajas principales de utilizar CFSM como lenguaje de especificación de contratos en Service Oriented Computing es que la naturaleza del binding en SOC choca con el método de establecer si un conjunto de participantes pueden interacturar libres de errores de comunicación. En SOC el descubrimiento y binding de servicios se realiza por demanda, eso significa que a pesar de que se necesiten muchos servicios para resolver una tarea, se obtienen uno por uno según se van necesitando. Por el otro lado las CFSM requieren el conjunto total de participantes de un protocolo para poder determinar si el protocolo puede llevarse a cabo sin errores. La idea de los ACFSA es intentar reducir la distancia entre ambas naturalezas. Por lo tanto una de las tareas principales que queremos lograr con ACFSAs es obtener, vía una proyección, la inferfaz de comunicación en la forma de una mCFSM.

\begin{definition}[Interfaz de comunicación de un ACFSA] Es la mCFSM que resulta de aplicarle el siguiente procedimiento a un aCFSA.
\begin{enumerate}
    \item Transformamos toda acción interna y de buffer en una transición $\epsilon$. Esto resulta en una autómata no determinístico con transiciones $\epsilon$
    \item Transformamos el autómata no determinístico rsultante del paso anterior en uno determinístico.
\end{enumerate}


\end{definition}

\subsection{GMC para mCFSMs}

En la sección 2.3 explicamos como funciona la condición de Generalized Multiparty Compatibility para CFSMs. Necesitamos ver que la misma condición es aplicable a las Multichannel CFSMs, para esto la solución más práctica que se encontró es ver que podemos emular una Multichannel CFSM con una CFSM pura. Mostrando esa equivalencia vemos que si podemos aplicar GMC al emulador, la condición aplica al emulado. Dado que un multichannel communicating system es libre de errores de comunicación si y solo si el sistema emulado también lo es. El procedimiento consiste en generar un nuevo participante para cada canal entre dos otros participantes. Este nuevo participante es un simple repetidor de mensajes de uno de los participantes a otro. De este modo una comunicación multichannel entre un par de participantes es reemplazada por múltiples comunicaciones de un canal con un repetidor en el medio. Una applicación de este procedimiento se ve en la Figura X. El aspecto clave de esta emulación es que preserva el orden de los mensajes.

\begin{definition}[Sistema emulado] Dado un multichannel communicating system $(M_p)_{p \in \mathcal{P}}$, agrandamos el conjunto $ \mathcal{P}$ agregando un participante adicional por cada canal en el sistema original $\mathcal{P}'=\mathcal{P} \cup \bigcup_{p \in \mathcal{P}} \{p^{pq_n} \ | \ pq_n \in \mathcal{C}_p \} \cup \bigcup_{p \in \mathcal{P}} \{p^{qp_n} \ | \ qp_n \in \mathcal{C}_p \}$. Cada participante nuevo $p^{sr_n} \in \bigcup_{p \in \mathcal{P}} \{p^{pq_n} \ | \ pq_n \in \mathcal{C}_p \} \cup \bigcup_{p \in \mathcal{P}} \{p^{qp_n} \ | \ qp_n \in \mathcal{C}_p \}$ se define con la siguiente mCFSM:
\begin{itemize}
\item $Q_{p^{sr_n}} = \{q_0\} \cup \bigcup_{m \in \mathcal{M}} \{q_m\}$
\item $\mathcal{C}_{p^{sr_n}} = \{sp_n^{sr_n}, p^{sr_n}r_n,  p^{sr_n}s_n, rp_n^{sr_n} \}$
\item $q_{0_{p^{sr_n}}} = q_0 $
\item $ \delta_{p^{sr_n}} = \bigcup_{m \in \mathcal{M}} \{ (q_0,sp_n^{sr_n}?m,q_m),(q_m,p^{sr_n}r_n!m,q_0)  \} $
\end{itemize}
Cada viejo participante $q \in \mathcal{P}$ se reemplaza por un nuevo participante $q'$ donde:
\begin{itemize}
\item $\mathcal{C}_{q'} = \{qp_n^{qr_n} \ | \ qr_n \in \mathcal{C}_{q} \} \cup \{p^{sq_n}q_n \ | \ sq_n \in \mathcal{C}_{q} \}$ 
\item $ \delta_{q'} = \bigcup_{m \in \mathcal{M}} \{ (q, qp_n^{qr_n}!m, q') \ | \ (q, qr_n!m, q') \in \delta_q \} \cup \{q, p^{sq_n}q_n?m,q' \ | \ (q, sq_n?m, q') \in \delta_q \}$

\end{itemize}

Queda claro que si bien transformamos cada canal (buffer) en dos canales nuevos, el orden de los mensajes está garantizado como resultado del modo en que $\delta$ está definido para los repetidores. Nótese que los repetidores respetan ese orden porque al consumir un mensaje desde el canal de "entrada" (el canal que sirve para recibir mensajes del emisor original) la única acción posible del repetidor es mandar el mensaje a través del canal de salida (el canal que sirve para enviar mensajes al receptor original). Como todo canal es FIFO y los repetidores se comportan del mismo modo, el orden entre dentro de cada canal queda garantiado. Por oro lado, no hay garantía respecto al orden de la comunicación entre canales del modelo original. Por lo tanto podemos decir que los repetidores no introducen más concurrencia que la que estaba en el modelo original y debido a eso los dos sistemas, a pesar de no ser bisimilares y no tener las mismas trazas, son equivalentes respecto a la ausencia de deadlock, recepciones no especificadas y mensajes huérfanos. Esta observación es importante porque provee una forma de chequear multichannesl communication systems recurriendo nuevamente al chequeo de GMC del sistema emulado.

\end{definition} 

\begin{prop} El sistema emulado preserva los errores comunicacionales

\begin{proof} Primero notemos que los repetidores no pueden generar errores de comunicación dado que en el estado inicial pueden recibir el rango completo de mensajes y luego de ocnsumir un mensaje su única acción posible es reenviarlo. Recordemos también que el orden de los mensajes se preserva. Esto significa que si en el sistema original los mensajes $ m $ y $m'$ fueron enviados en ese orden sobre el canal $sr$ en el sistema emulado se envían en el mismo orden sobre el canal $sp^{sr}$ y por lo tanto son enviados en ese mismo orden a través del canal $p^{sr}r$. Entonces se puede mostrar que para cada error de configuración alcanzable en el sistema original, hay una configuración que presenta el mismo error que es alcanzable en el sistema emulado y viceversa.
\begin{itemize}
\item[$\Rightarrow$] Consideremos cualquier configuración de error $e$ alcanzable en el sistema original y consideremos cualquier camino que alcance $e$. Luego reemplacemos toda acción $sr!m$ con la secuencia de acciones $sp^{sr}!m, sp^{sr}?m, p^{sr}r!m$ y cada acción $sr?m$ con $p^{sr}?m$, este nuevo camino está presente en el sistema emulado y alcanza el estado donde las configuraciones de buffer y transiciones permitidas son las mismas para el conjunto de máquinas compartidas (es decir, todas las máquinas de sistema emulado menos los repetidores) y los repetidores están en su estado inicial con buffers vacíos.
\item$\Leftarrow$ Consideremos cualquier error de configuración $e$ alcanzable en el sistema emulado y ocnsideremos cualquier camino que alcance $e$. Ya establecimos que el error no puede ser culpa de los repetidores dado que siempre pueden progresar. Por lo tanto sin importar el estado de los buffers en $e$ hay una configuración $e'$ que presenta el mismo error de comunicación y donde el estado de los buffers de los repetidores está vacío y están en su estado inicial. Luego consideremos que cualquier camino que alcance $e'$ está formado por secuencias de la forma $sp^{sr}!m,\ldots, sp^{sr}?m, \ldots, p^{sr}r!m$ y $p^{sr}r?m$ (donde los puntos suspensivos denota la posibilidad de interleaving de otras acciones). Entonces alcanza con reemplazar cada secuencia $sp^{sr}!m,\ldots_0, sp^{sr}?m, \ldots_1, p^{sr}r!m$ con la secuencia $\ldots_0,\ldots_1, sr!m$ y cada $p^{sr}r?m$ con $sr?m$ para obtener un camino que existe en el sistma original y aclanza una configuración que tiene sus buffers en el mismo estado con las mismas transiciones permitidas.
\end{itemize}

\end{proof}

\end{prop}


\section{Trabajo futuro} 



\begin{definition} Sea $\mathcal{P}$ un conjunto de participantes, $\mathcal{C}$ un conjunto de canales de comunicación unidireccionales y $\mathcal{M}$ un conjunto de mensajes. Un autómata es una es una estructura $A_\mathcal{P} = \langle Q, B, \Sigma, \delta, q_0, F\rangle$ tal que:

\begin{itemize}
\item $Q$ es un conjunto finito de estados,
\item $B$ es el conjunto de nombres de buffers,
\item $\Sigma = \{ \Sigma_\mathit{Int} \cup \Sigma_\mathit{Ex} \cup \Sigma_\mathit{Buff}\} $ es el conjunto de etiquetas del autómata, siendo:
\begin{inparaenum}[1)]

\item $\Sigma_\mathit{Int}$ las acciones internas del autómata 

\item $\Sigma_\mathit{Ex}$ un conjunto de etiquetas de la forma $\langle p_1,p_2,c\rangle$ dónde $p_1,p_2 \in \mathcal{P}$ son, respectivamente, el emisor y el receptor de la comunicación y $c \in \mathcal{C}$ es el canal a través del cual se resuelve la misma.
%\item $\forall (p_1,P_2,c), (p'_1,P'_2,c') \in \Sigma_{Ex} c = c' \iff p_1= P'_1 \land p_2= P'_2 $

\item $\Sigma_\mathit{Buff}$ es el conjunto de etiquetas de las acciones sobre los buffers de la forma $b \ll m$ o $b \gg m$, dónde $b \in B$ y $m \in \mathcal{M}$.
\end{inparaenum}
\item $\delta = (\delta_\mathit{Int} \cup \delta_\mathit{Ex} \cup \delta_\mathit{Buff})$ siendo:

\begin{inparaenum}[1)]
\item $\delta_\mathit{Int} \subseteq Q \times \Sigma_\mathit{Int} \times Q$ es la relación de transicion por acciones internas de $A_\mathcal{P}$, %transiciones internas

\item $\delta_\mathit{Ex} \subseteq Q \times \{\mathit{In}(c,m), \mathit{Out}(c,m) | c \in \Sigma_{Ex} \land m \in \mathcal{M} \} \times Q$ es la relación de transición de comunicación externa de $A_\mathcal{P}$, %comunicación externa

\item $\delta_\mathit{Buff} \subseteq Q \times \Sigma_\mathit{Buff} \times Q$ %comunicación interna
\end{inparaenum}
\item $q_0 \in Q$ es el estado inicial, y
\item $F \subseteq \mathit{Partes(Q)}$ es el conjunto de conjuntos de estados finales. 
\end{itemize}

Se denota $P(A)$, al conjunto de participantes que integran el autómata A, y se define como $P(A) = \{ p \in \mathcal{P} \ | (\exists\ \langle p1,p2,c\rangle \in \Sigma_\mathit{Ex})(p1=p \lor p2=p) \} $ 
\end{definition}

Los autómatas de asincrónicos reactivos se comportan como los autómatas asincrónicos de comunicación en casi todo sentido. La diferencia principal es que con estos queremos representar el comportamiento de sistemas que no tienen una ejecución finita. Para esto tomamos comportamiento de los autómatas de Muller que nos genera una condición de aceptación doble. En este caso el conjunto de estados finales es un conjunto de conjuntos y decimos que el sistema terminó su ejecución cuando pasa al menos una cantidad infinita de veces por alguno de los conjuntos que componen a F. Para asegurarnos de que la ejecución sea correcta, pedimos también que en ese ciclo infinito los buffers estén vacíos.


\section{Conclusiones}

\section{Bibliografía}
\begin{thebibliography}{}
\bibitem{CFSM}D. Brand and P. Zafiropulo. On communicating finite-state machines. Journal of the ACM, 30(2):323-342, 1983.
\bibitem{Communicating System}Julien Lange, Emilio Tuosto, Nobuko Yoshida. From Communicating Machines to Graphical ChoreographiesIn S. K. Rajamani and D. Walker, editors, Proceedings of 42rd. Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, POPL ’15, pages 221–232, New York, NY, USA, 2015. ACM.

\end{thebibliography}


\end{document}